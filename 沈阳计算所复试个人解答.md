

# SCIT_Interview

[toc]

## 2006

### 程序设计

#### T1（基本程序设计）

编写一个程序，对输入的一行字符，分别统计出其中英文字母、空格、数字和其它字符各自的数目。

```c
#include <stdio.h>

int main()
{
	int Char_C = 0, Num_C = 0, Black_C = 0, Other_c = 0, i = 0;
	char str[100];
	while (scanf("%c", &str[i]) != EOF)
	{
		if ((str[i] <= 'Z' && str[i] >= 'A') || (str[i] <= 'z' && str[i] >= 'a'))
		{
			Char_C++;
		}
		else if (str[i] <= '9' && str[i] >= '0')
		{
			Num_C++;
		}
		else if (str[i] == ' ')
		{
			Black_C++;
		}
		else
		{
			Other_c++;
		}
		i++;
	}
	printf("字母数目:%d\n", Char_C);
	printf("数字数目:%d\n", Num_C);
	printf("空格数目:%d\n", Black_C);
	printf("其他字符数目:%d\n", Other_c);
	return 0;
}
```



#### T2（基本程序设计）

有n个整数，使前面各数顺序向后移m个位置，最后m个数变成最前面的m个数，如下图所示

![image-20230217183405006](https://gowi-picgo.oss-cn-shenzhen.aliyuncs.com/202302171834742.png)

```c
#include <stdio.h>

int main(void)
{
	int A[100] = {0}, n, m;
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; ++i)
	{
		scanf("%d", &A[(i + m < n) ? i + m : (i + m) % n]); //把A[i]往后移动m位置
	}
	for (int i = 0; i < n; ++i)
	{
		printf("%d ",A[i]);
	}
	return 0;
}

```

### 数据结构

#### T1（二叉树的前序遍历（非递归））

一棵n个结点的完全二叉树以向量作为存储结构，试写一非递归算法实现对该树的前序遍历

```c
//主要思路采用数组下标来模拟栈的操作，其中因为数组是从0开始的，所以i的左子树为2*i+1右子树为2*(i+1),即当i为左子树(i为奇数)时i/2为其父节点，i为右子树(i为偶数)时i/2-1为i的父节点
#include <stdio.h>

#define Num 18

int main()
{
	int BiTree[Num], visited[Num] = {0}, n = Num, i = 0, k = 0;
	for (int i = 0; i < n; ++i)
	{
		BiTree[i] = i;
	}
	while (k < n)//当n个节点全部访问完成退出循环
	{
		if (i < n && visited[i] != 1)
		{
			printf("%d,", BiTree[i]);//访问节点
			visited[i] = 1;
			k++;
			i = i * 2 + 1; //寻找左子树
		}
		else // 如果左子树为空，则寻找其右子树
		{
			i = i / 2; //节点i（i其实不存在二叉树中，i已经超过来二叉树的节点范围）
			if (i % 2) //寻找i的父节点，即上次被访问的节点
			{
				i = i / 2; //i若为左子树时,i/2为i的父节点
			}
			else
			{
				i = i / 2 - 1;//若i为左子树时，i/2-1为i的父节点
			}
			while (1)//不断往上寻找有为被访问的左子树后者右子树，相对于递归的回退部分
			{
				if (visited[2 * i + 1] == 0)//若i的左子树为被访问
				{
					i = 2 * i + 1;//i为i的左子树
					break;
				}
				if (visited[2 * (i + 1)] == 0)//i的右子树
				{
					i = 2 * (i + 1);//i为i的右子树
					break;
				}
				if (i % 2)//寻找其父节点
				{
					i = i / 2;
				}
				else
				{
					i = i / 2 - 1;
				}
			}
		}
	}
	return 0;
}
```



### 操作系统

#### T1（进程切换）

叙述进程上下文在进程执行活动中起什么作用，它（指进程上下文）都包括哪些部分，举例简述Unix System V上下文的组成情况。

本人：

相关的寄存器、指令和数据以及堆栈

>   参考答案：
>
>   进程上下文实际上是进程执行活动**全过程的静态描述**。进程上下文包括**计算机系统中与执行该进程有关的各种寄存器的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构**。
>
>   进程上下文是可以按照层次规则组合起来的。例如在UNIX System V中，进程上下文由用户级上下文，寄存器上下文以及系统级上下文组成。用户级上下文由进程的用户程序段部分编译而成的用户正文段，用户数据，用户栈组成。寄存器上下文则有程序寄存器PC，处理机状态寄存器PS，栈指针和通用寄存器的值组成。
>
>   进程上下文包含：**每个进程执行过的、执行时的以及待执行的指令和数据；在指令寄存器、堆栈、状态字寄存器等中的内容**。



#### T2（基本分页存储）

按照下面的要求，说出页式管理的实现过程.

(1)  虚拟空间如何划分页；

本人：

虚拟空间？

>   参考答案：
>
>   用固定大小的**页(Page)**来描述逻辑地址空间，用相同大小的**页框(Frame)**来描述物理内存空间，由操作系统实现从逻辑页到物理页框的**页面映射**，同时负责对所有页的管理和进程运行的控制.
>
>   每个进程以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。



(2)  内存空间如何划分页面；

本人：

操作系统会将内存以块为单位划分，其每个块的大小是固定的。

>   参考答案：
>
>   将主存空间划分为大小相等的的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的快空间。

(3)  地址变换如何实现；

本人：

操作系统会建立页表，其中程序在编译时会生成逻辑地址，而逻辑地址分为两部分前部分为页号，而后部分为页内偏移量，让页号会和页表长度作比较若超出，则发生越界中断，否则在相应的页表中找到相应的块号，然后更具块号得出当前块的物理地址然后与页内偏移地址相加，得到当前逻辑地址到物理地址到映射。

>   参考答案：
>
>   页表在内存中起始地址F，页表长度M，页面大小L，逻辑地址A到物理地址E的变换过程如下：
>
>   ​    1：计算页号P（P=A/L）和页内偏移量W（W=A%L）
>
>   ​    2：比较页号P和页表长度M,若P>=M，越界中断，否则继续
>
>   ​    3：页表中页号P对应的页表项的地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b，即为物理地址
>
>   ​    4：计算E=b*L+W，用得到的物理地址E去访问内存



(4)  请求调页和预调页解决什么问题。

本人：

请求调页是虚拟存储中的一种方式，当需要请求的页不在内存中时，发生缺页中断，把需要请求的页调入内存中，若内存中已经满页，则从内存中调用页面置换算法选择一页与当前请求页置换；若内存中没有满页，则直接将页调入内存。

预调页是根据局部性原理，来采用的措施，从而降低缺页率，从而提高操作系统的效率。

两者都提高了操作系统的效率，从逻辑上扩大了内存。

>   参考答案:
>
>   页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理，逻辑上扩大了内存的容量。



相关扩展：

动态页式管理是在静态页式管理的基础上发展起来的。它分为请求页式管理和预调入页式管理。 请求页式管理和预调入页式管理在==作业或进程开始执行之前==，都不把作业或进程的程序段和数据段一次性地全部装入内存，而只装入被认为是经常反复执行和调用的工作区部分。其它部分则在执行过程中动态装入。请求页式管理与预调入页式管理的主要区别在它们的调入方式上。

**预调入方式是，系统对那些在外存中的页进行调入顺序计算。估计出这些页中指令和数据的执行和被访问的顺序，并按此顺序将它们顺次调入和调出内存。除了在调入方式上请求页式管理和预调入管理有些区别之外，其它方面这两种方式基本相同。因此，下面我们主要介绍请求页式管理。**

请求页式管理的调入方式是，当需要执行某条指令而又发现它不在内存时或当执行某条指令需要访问其它的数据或指令时．这些指令和数据不在内存中，从而发生缺页中断，系统将外存中相应的页面调入内存。

虚拟内存是在磁盘上的一块区域，用以扩充主存的容量。虚拟内存里放的数据是内核不常用的信息，内存管理机制会把这些不常用的内存块保存到磁盘上，当要使用时再重新调入主存。虚拟内存的速度比主存慢很多。用作虚拟内存的磁盘空间叫交换空间(swap)。在Linux下，交换空间可以是一个分区，叫交换分区；也可以是一个文件，叫交换文件。交换分区速度快，但一旦设置，不易修改分区大小；交换文件速度较交换分区慢，但它的容量可随意调整。建议使用交换分区的形式。



#### T3（进程调度）

回答有关进程管理的问题。

（1） 进程调度可分为哪两种基本方式？

本人：

抢占式与非抢占式

>   参考答案：
>
>   非剥夺调度方式与剥夺调度方式

（2）   对于这两种进程调度的基本方式，哪一种系统的开销更大？为什么？

本人：

抢占式开销更大；当当前进程的时间片没有使用完时，出现了一个比其优先级更高的进程，则需抢占当前进程的处理机资源，则必须保存当前进程的状态，并且发生进程的调度，所以抢占式需要更多的开销。

>   参考答案：
>
>   剥夺调度方式开销更大，由于调度程序的执行涉及到多个进程和必须进行上下文切换，如果调度程序过于繁琐和复杂，将会耗去较大的系统开销。这在用户进程调用系统调用较多的情况下，将会造成响应时间大幅度增加。

（3）   常见的进程调度的算法又哪些？

本人：先来先服务算法、短作业优先算法、时间片轮转算法、优先级抢占算法、多级反馈队列算法、高响应比优先算法、最短剩余时间抢占算法。

>   参考答案：
>
>   FCFS,SJF,时间片轮转，优先级调度算法，高响应比优先调度算法，多级反馈队列调度算法



#### T4（内存管理）

 <font color=red>回答有关存储管理的问题。</font>

（1）什么是动态链接？

本人：问到点子上了，这不知道在哪看见过有点印象，但是记不得了

>   参考答案：
>
>   动态链接分**装入时动态链接**和**运行时动态链接**，装入时动态链接：将用户源程序编译后所得的一组目标模块，==在装入内存时，采取边装入边链接的链接方式==。运行时动态链接时在==执行时需要该目标模块时，才对它进行链接==，其优点是便于修改和更新，便于实现对目标模块的共享。

（2）用何种内存分配方法可以实现这种链接技术？为什么？

本人：上面一个都不知道怎么知道这个

>   参考答案：
>
>   可以用分页和分段内存分配来实现，因为通过地址映射可以实现逻辑地址和物理地址的对应。



## 2007

### 程序设计

#### T1（基本程序设计）

输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组

```c
#include <stdio.h>

#define N 100

int main()
{
	int A[N] = {0}, n, max_index = 0, min_index = 0;
	scanf("%d", &n);
	for (int i = 0; i < n; ++i)
	{
		scanf("%d", &A[i]);
		if (A[i] < A[min_index])
		{
			min_index = i;
		}
		if (A[i] > A[max_index])
		{
			max_index = i;
		}
	}
	int temp;
	if (min_index == 0 && max_index == n - 1)//若最大的数为数组最后一个数字且最小的数字为数组第一个数字则只需要交换两者位置，否则和相应位置的数字交换
	{
		temp = A[max_index];
		A[max_index] = A[min_index];
		A[min_index] = temp;
	}
	else
	{
		temp = A[0];
		A[0] = A[max_index];
		A[max_index] = temp;
		temp = A[n - 1];
		A[n - 1] = A[min_index];
		A[min_index] = temp;
	}
	for (int i = 0; i < n; ++i)
	{
		printf("%d,", A[i]);
	}
	return 0;
}
```



#### T2（基本程序设计）

 编程将一个实数分解为它的整数和小数部分。

```c
#include <stdio.h>

int main()
{
	float a, c;
	int b;
	scanf("%f", &a);
	b = a;//隐性类型转换
	c = a - b;
	printf("整数部分:%d\n", b);
	printf("小数部分:%f\n", c);
	return 0;
}
```

### 数据结构

#### T1（单链表的应用）

已知单链表L是一个递增有序表，试写一高效算法，删除表中值大于min且小于max的结点（若表中又这样的结点），同时释放被删结点的空间，这里的min和max是两个给定的参数。请分析你的算法时间复杂度。

```c
#include <stdio.h>
#include <stdlib.h>

struct LNode
{
	struct LNode *next;
	int data;
};

typedef struct LNode LNode;
typedef struct LNode LinkList;

LinkList *CreatList_pre(LinkList *L)
{
	int a;
	LNode *p = L;
	while (scanf("%d", &a) && a != -1)
	{
		LNode *q = (LNode *) malloc(sizeof(LNode));
		q->data = a;
		p->next = q;
		q->next = NULL;
		p = p->next;
	}
	return L;
}

LinkList *CreatLinkList_post(LinkList *L)
{
	int a;
	LNode *p = L;
	while (scanf("%d", &a) && a != -1)
	{
		LNode *q = (LNode *) malloc(sizeof(LNode));
		q->data = a;
		q->next = p->next;
		p->next = q;
	}
	return L;
}

int IsEmpty(LinkList *L)
{
	if (L->next == NULL)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

void print_LinkList(LinkList *L)
{
	if (IsEmpty(L))
	{
		printf("链表为空\n");
	}
	else
	{
		for (LNode *p = L->next; p != NULL; p = p->next)
		{
			printf("%d->", p->data);
		}
		printf("NULL\n");
	}
}


LinkList *Delete_Between_Min_And_Max(LinkList *L, int min, int max)
{
	for (LNode *p = L; p != NULL;)
	{
		if (p->next != NULL && p->next->data < max && p->next->data > min)
		{
			LNode *q = p->next;
			p->next = p->next->next;
			free(q);
		}
		else
		{
			p = p->next;
		}
	}
	return L;
}

int main()
{
	int min, max;
	LinkList *L = (LinkList *) malloc(sizeof(LNode));
	L = CreatList_pre(L);
	scanf("%d %d", &min, &max);
	Delete_Between_Min_And_Max(L, min, max);
	print_LinkList(L);
	return 0;
}

LinkList *Delete_Between_Min_And_Max(LinkList *L, int min, int max)
{
	for (LNode *p = L; p != NULL;)
	{
		if (p->next != NULL && p->next->data < max && p->next->data > min)
		{
			LNode *q = p->next;
			p->next = p->next->next;
			free(q);
		}
		else
		{
			p = p->next;
		}
	}
	return L;
}

int main()
{
	int min, max;
	LinkList *L = (LinkList *) malloc(sizeof(LNode));
	L = CreatList_pre(L);
	scanf("%d %d", &min, &max);
	Delete_Between_Min_And_Max(L, min, max);
	print_LinkList(L);
	return 0;
}
```



#### T2（二叉树的高度与宽度）

以二叉链表为存储结构，分别写出求二叉树高度算法及高度算法，所谓宽度是指二叉树的各层上，具有结点数最多的那一层上的结点总数。







#### T3（二叉树层次遍历）

以二叉链表为存储结构，一算法对二叉树进行层次遍历(层次遍历的定义见6.13).提示：应使用队列来保存各层的结点。 



## 2008

### 程序设计

#### T1（结构体程序设计与文件操作）

有5个学生，每个学生又三门课的成绩，从键盘输入学生数据（包括学生号、姓名、三门课的成绩），计算出平均成绩，将原有数据和计算出的平均分数存放在磁盘文件“stud”中。

```c
#include <cstdio>
#include <cstdlib>

#define N 5

struct Stduent
{
	int no;
	char name[10];
	int score1;
	int score2;
	int score3;
	int avg_score;
};

typedef struct Stduent Student;

int main()
{
	Stduent std[N];
	FILE *f;
	f = std::fopen("stdu.txt", "w+");
	if (f == NULL)
	{
		printf("文件创建失败!\n");
		exit(0);
	}
	for (int i = 0; i < N; ++i)
	{
		scanf("%d", &std[i].no);
		scanf("%s", std[i].name);
		scanf("%d", &std[i].score1);
		scanf("%d", &std[i].score2);
		scanf("%d", &std[i].score3);
		std[i].avg_score = (std[i].score1 + std[i].score2 + std[i].score3) / 3;
		fprintf(f, "%d,%s,%d,%d,%d,%d\n", std[i].no, std[i].name, std[i].score1, std[i].score2, std[i].score3,
				std[i].avg_score);
	}
	fclose(f);
	return 0;
}
```

#### T2（字符数组）

编写程序，将字符串中第n个字符开始的全部字符复制成另一个字符串。要求在主函数中输入字符串及n的值并输出复制的结果，在被调用函数中完成复制。

```cpp
#include <cstdio>

#define N 100

void strCpy(char *str1, char *str2, int n)
{
	int i = n, j = 0;
	for (; str1[i] != '\0'; i++, j++)
	{
		str2[j] = str1[i];
	}
	str2[j] = '\0';
}

int main()
{
	char str1[N], str2[N];
	int n;
	scanf("%d", &n);
	scanf("%s", str1);
	strCpy(str1, str2, n);
	printf("%s\n", str2);
}
```

### 数据结构

#### T1（二叉树的中序遍历（非递归））

请写出二叉树的中序非递归遍历的基本思想，然后写出算法，实现对二叉树的中序非递归遍历





#### T2（图的邻接表表示与拓扑排序）

对于一个使用邻接表存储的有向图G，可以利用深度优先遍历方法，对该图结点进行拓扑排序。其基本思想是：在遍历过程中，每访问一个顶点，就将其邻接到的顶点的入度减一，并对其未访问的、入度为0的邻接到的顶点进行递归。
       （1）、给出完成上述功能的图的邻接表的定义（结构）。（3分）
       （2）、定义在算法中使用的全局辅助数组。（2分）
       （3）、写出在遍历图的同时进行拓扑排序的算法。（10分）







### 操作系统

#### T1（进程与线程）

进程与线程的主要区别是什么？

本人：

在传统操作系统中，进程为程序系统资源分派和调度的基本单位，而引入线程后，线程为处理机调度的基本单位，而进程作为资源分派的基本单位。进程拥有独立的资源，而进程没有属于自己的资源。



>   参考答案1：
>
>   进程和线程区别
>
>   1.  拥有资源：无论是传统还是有线程的操作系统，进程都是拥有资源的基本单位，但线程可访问隶属于进程的资源。
>   2.  并发性：引入线程操作系统中，不仅进程间可以并发，同一进程中多线程也可以并发
>   3.  调度：在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。同一进程中，线程切换不会引起进程切换，而不同进程进行切换会引起线程切换。
>   4.  地址空间和其它资源：地址空间互相独立，同一进程各线程间共享进程的资源，某进程内线程对其它进程不可见。
>
>    
>
>   另：进程和程序的区别
>
>   1.  进程为程序及其数据在计算机上的一次运行活动，为一个动态概念。静态来看包括程序，数据和PCB。而程序是一组有序的指令集合，静态概念。
>   2.  进程是程序的一次执行过程，动态创建和消亡，有一定的生命周期。程序为一组指令集合，可长期保存。
>   3.  一进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，程序不可以创建程序。



>   参考答案2：
>
>   线程具有许多传统进程所具有的特征，故又称为轻型进程或进程元；而把传统的进程称为重型进程，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少也需要有一个线程。下面从调度、并发性、系统开销、拥有资源等方面，来比较线程与进程。
>
>   (1) 调度。在传统操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位，使传统进程的两个属性分开，线程便能轻装运行，从而提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，在由一个进程中的线程切换到另一进程中的线程时，将会引起进程切换。
>
>    (2) 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统的吞吐量。
>
>    (3) 拥有资源。不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。一般来说，线程不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源。亦即，一个进程的代码段、数据段以及系统资源，如已打开的文件、I/O设备等，可供同一进程的所有线程共享。
>
>    (4) 系统开销。在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及整个当前进程CPU环境的保存以及新被调度运行的进程CPU环境的设置。而进程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，使两者之间的同步和通信的实现也变得比较容易，在有的系统中，线程的切换、同步和通信都无须需操作系统内核干预。

#### T2（内存管理）

比较分段式与分页式存储管理方式的主要差别。

分段式存储：

分段式存储是指操作系统把内存分段，每一个段存储程序中的一个模块，并为其建立相应的段表，使其完成逻辑地址到物理地址的映射。

分页式存储：

分页式存储是指操作系统把内存分成每个大小相等的块，将进程放入块中，并为其建立相应的页表，使其完成逻辑地址到物理地址的映射。

区别：

在分段式存储中，每一个段的大小不一的相等，并为其建立段表，而在分页式存储中每一个页的大小是相等的，并为其建立页表。

>   参考答案1:
>
>   |                | 分页                                                         | 分段                                                         |
>   | -------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
>   | 目的           | 页是信息物理单位，分页为实现离散分配方式，提高内存利用，提高内存利用率 | 段是信息逻辑单位，它含有一组其意义相对完整的信息。分段目的是为了更好地满足用户的需要 |
>   | 长度           | 页大小固定且由系统决定，由系统将逻辑地址分为页号和页内地址，是由机器硬件实现的 | 段长不固定，通常由编译程序对流程序编译时根据信息性质来划分的。 |
>   | 地址空间       | 作业地址空间是一维的，即单一线性地址线性空间，只需一个标志符即可表示一个地址。 | 作业地址空间是二维的，程序员在标志一个地址时，既需要给出段名，又需要给出段内地址 |
>   | 碎片           | 有内部碎片，无外部碎片                                       | 有外部碎片无内部碎片                                         |
>   | 动态链接和共享 | 不易实现                                                     | 容易实现                                                     |



>   参考答案2:
>
>   1.  页是信息的物理单位,是系统管理的需要。段是信息的逻辑单位,==它含有一组意义相对完整的信息==,分段的目的是为了更好地实现共享,满足用户的要求。
>   2.  页的大小固定且由系统确定。(即将逻辑地址划分为页号和页内地址是由机器硬件实现的)段的长度不固定,因段而异,它取决于用户所编写的程序（通常由编译程序在对源程序进行编译时根据信息的性质来划分）。
>   3.  分页的进程空间是一维的（只要一个逻辑地址便可以通过取余数和除法操作，便可以得到页内偏移和页号，在根据页表可以得到其物理地址）,分段式进程空间是==二维的==（因为段长不少固定的，所以必须由用户显式的给定段长和段号才可以得到物理地址）。
>   4.  分页系统很难实现过程和数据的分离。不便于实现共享,也无法分别对过程和数据提供保护。分段系统确可以很容易实现共享与保护。



## 2009

### 程序设计

#### T1





#### T2





### 数据结构

#### T1（二叉树的高度与宽度）

以二叉链表为存储结构，分别写出求二叉树高度算法及高度算法，所谓宽度是指二叉树的各层上，具有结点数最多的那一层上的结点总数。



#### T2（图的邻接表表示与拓扑排序）

对于一个使用邻接表存储的有向图G，可以利用深度优先遍历方法，对该图结点进行拓扑排序。其基本思想是：在遍历过程中，每访问一个顶点，就将其邻接到的顶点的入度减一，并对其未访问的、入度为0的邻接到的顶点进行递归。

​    （1）、给出完成上述功能的图的邻接表的定义（结构）。（3分）

​    （2）、定义在算法中使用的全局辅助数组。（2分）

​    （3）、写出在遍历图的同时进行拓扑排序的算法。（10分）







### 操作系统

#### T1（进程基本概念）（❌）

进程的最基本特征是（ ）和（ ），在Unix系统中，可通过调用系统（  ）来创建进程，系统调用（ ）来实现进程的自我终止，引入进程的主要目的是（  ）。

本人：

并发性、共享性、creat、exit、提高系统的并发性



>   参考答案：
>
>   进程最基本的特征是（==动态==）和（==并发==），在Unix系统中，可以通过调用系统调用(==fork==)来创建进程，系统调用（==exit==）来自我终止，引入进程主要目的是（==为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性==）。
>
>   扩展：
>
>   并发和共享是==操作系统==两个==最基本==的特征



#### T2（多道程序设计）

什么是多道程序设计？在OS中引入该技术，带了什么好处？

本人：

多道程序设计技术是指：操作系统容许有多道程序驻留内存中。使用多道程序设计技术容许操作系统在不同进程中切换，大大地提高了操作系统的并行性，处理机的利用率。

>   参考答案1:
>
>   多道程序设计是指计算机内存中同时存放几道相互独立的程序，他们受内存管理程序的控制下相互交替的运行。==其特征为：多道，宏观并行，微观串行==。提高了资源利用率和系统吞吐量



#### T3（虚拟存储）（❌）

虚拟存储器具有哪些基本特征？实现虚拟存储器的几个关键技术是什么?

本人：

虚拟存储器：进程的页不必全部驻留在内存中，当发生缺页时，操作系统从外存中调入相应的页，若内存中的页面已满，则采用页面置换算法将相应的页调出内存，然后把所需的页调入内存中，使得内存好像从逻辑上得到的扩大。

虚拟存储器的基本特征：进程不必全部驻留内存

关键技术：缺页中断、页面调用算法



>   参考答案：
>
>   基本特征：多次性，对换性和虚拟性
>
>   关键技术：一定容量的内存和外存；页表机制，作为主要的数据结构；中断机构，当用户要访问的部分尚未调入内存，则产生中断；地址变换机构，逻辑地址到物理地址的变换。



## 2010

### 程序设计

#### T1（数据类型）

在C语言中，int、char、和short三种类型数据在内存中所占的字节数（ ）

A、用户自己定义 

B、均为2个字节

C、是任意的

D、由所用的机器的机器字长决定

本人：

D

>   参考答案:
>
>   D、解析：C语言中，常用的数据类型有int，char，float，double等，但C标准没有具体规定以上各类数据所占内存字节数，只要求long型数据长度不短于int型，short型不长于int型，具体如何实现，由各计算机系统自行决定。



#### T2（算符优先级）

下列运算符优先级最低的是（ ）

A、 ？：

B、+=  

C、>= 

D、 ==

本人：

A

>   参考答案:
>
>   A



#### T3（while循环）

语句while（!E）表达式!E等价于（ ）

A、E=\=0 

B、 E!=1  

C、 E!=0 

D、 E=\=1

本人：

A

>   参考答案:
>
>   A、如果“!E”是真命题就执行while语句,真命题的条件是“!e!=0”,也就是“E=\=0”.即E=\=0时执行while语句.



#### T4（函数指针）（❌）

已知函数max（a，b）中，为了让函数指针变量p指向函数max，正确的赋值方法是（ ） 

A、p=max 

B、 *p=max  

C、 p=max(a,b)  

D、 *p=max(a,b)

本人：D

>   参考答案：
>
>   A
>
>   函数指针

<font color=red size=17>重点</font>

```c
int (*p1)[5];//数组指针，指向长度为5的int型数组
int *p2[5];//指针数组
int *func1(int a, int b); //声明一个指针函数
int (*func2)(int a,int b);// 声明一个函数指针
int add(int a, int b)
{
	return a + b;
}
func2 = add;//函数指针的赋值
int c=func2(3, 4)//函数指针的使用
```



#### T5（共用体）（❌）

以下程序的运行结果是（ ）

```c
#include <cstdio>

union pw
{
	int i;
	char ch[2];
} a;

int main()
{
	a.ch[0] = 13;
	a.ch[1] = 0;
	printf("%d\n", a.i);
}
```

A、13 

B、 14 

C、 208 

D、 209



本人：

共用体共享内存，给char赋值数字应该是ascii码，数组连续分配的地址，转化成int，不会

>   参考答案：
>
>   A
>
>   [解析] 在本题中，首先定义了一个共用体pw，其中有两个域：整型变量i和字符数组ch，因为共用体中的域是共享内存空间的，数组元素由低到高存储：ch[0]在低字节，ch[1]在高字节。整型变量i占两个字节，高位与ch[1]共用存储空间，低位与ch[0]共用存储空间。而高位ch[1]的值为0，所以输出的成员变量i的值就是ch[0]的值13。



#### T6（字符数组）

编写程序，将字符串中第m个字符开始的全部字符复制成另一个字符串。要求在主函数中输入字符串及m的值并输出复制结果，在被调用的函数中完成复制。



```cpp
#include <cstdio>

#define N 100

void strCpy(char *str1, char *str2, int n)
{
	int i = n, j = 0;
	for (; str1[i] != '\0'; i++, j++)
	{
		str2[j] = str1[i];
	}
	str2[j] = '\0';
}

int main()
{
	char str1[N], str2[N];
	int n;
	scanf("%d", &n);
	scanf("%s", str1);
	strCpy(str1, str2, n);
	printf("%s\n", str2);
}
```

#### T7 （字符数组）

完成一个函数：

char *BeforData(char *today)

说明：today是输入的日期，格式为“YYYY-MM-DD”，返回也为“YYYY-MM-DD”，

返回值为输入值的前一天，如：today = “2017-03-19”，返回：“2017-03-18”



```cpp
#include <cstdio>

char *BeforeData(char *today)
{
	char bd[11];
	int year = 0, month = 0, day = 0;
	for (int i = 0; i < 10; ++i)
	{
		if (i < 4)
		{
			year = year * 10 + today[i] - '0';
		}
		else if (i < 7 && i > 4)
		{
			month = month * 10 + today[i] - '0';
		}
		else if (i > 7)
		{
			day = day * 10 + today[i] - '0';
		}
	}
	if (day == 1)
	{
		if (month == 1)
		{
			month = 12;
			year--;
		}
		else if (month - 1 == 1 || month - 1 == 3 || month - 1 == 5 || month - 1 == 7 || month - 1 == 9 ||
				 month - 1 == 10 || month - 1 == 12)
		{
			month--;
			day = 31;
		}
		else if (month - 1 == 2)
		{
			if (year % 4 == 0 || year % 400 == 0)
			{
				month--;
				day = 29;
			}
			else
			{
				month--;
				day = 28;
			}
		}
		else
		{
			month--;
			day = 30;
		}
	}
	else
	{
		day = day - 1;
	}
	int k = 1000;
	for (int i = 0; i < 10; ++i)
	{
		if (i < 4)
		{
			bd[i] = year / k + '0';
			year = year % k;
			k /= 10;
		}
		else if (i == 4)
		{
			bd[i] = '-';
			k = 10;
		}
		else if (i < 7)
		{
			bd[i] = month / k + '0';
			month = month % k;
			k /= 10;
		}
		else if (i == 7)
		{
			bd[i] = '-';
			k = 10;
		}
		else
		{
			bd[i] = day / k + '0';
			day = day % k;
			k /= 10;
		}
	}
	bd[10] = '\0';
	printf("%s\n", bd);
	return bd;
}

int main()
{
	BeforeData("2023-02-19");
}
```

 



### 数据结构

#### T1（线性表）

某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用（ ）存储方式最节省运算时间。

A、单链表 

B、仅有头指针的单循环链表 

C、双链表 

D、仅有尾指针的单循环链表



本人：

D

>   参考答案：
>
>   D、在最后一个元素后面插入元素，需要知道最后一个元素的指针，故A和C的时间复杂度为O(n)。B因为没有特殊的指针指示头结点或尾结点，故需从某一结点向固定的方向顺序依次搜索插入和删除的位置，时间复杂度也为O(n)。

#### T2 （时空复杂度）

对于顺序存储的线性表，访问结点和增加、删除节点的复杂度为（ ）

A、 O(n) O(n)  

B、 O(n) O(1) 

C、 O(1) O(n) 

D、 O(1) O(1) 

本人：

C

>   参考答案：
>
>   C
>
>   顺序存储可以实现“随机存取”，因此访问结点的时间复杂度为O(1)，而插入、删除结点由于涉及到大量移动元素，故其时间复杂度为O(n)。



#### T3 （栈的基本操作）

若已知一个栈的入栈顺序是1，2，3，···，n，其输出序列为p1,p2,p3···pn，若pn是n，则pi是（ ） 

A、 i 

B、 n-i 

C、 n-i+1 

D、 不确定

本人：

A

>   参考答案：
>
>   A
>
>   每一个元素依次先进栈再出栈

#### T4 （二叉树的遍历）

树的后序遍历序列等同于该树对应的二叉树的（ ）

A、 先序遍历 

B、 中序遍历 

C、后序遍历 

D、 不确定

本人：

B

#### T5  （哈夫曼树与前缀编码）

下面几个符号串编码集合中，不是前缀编码的是（ ）

A、{0,10.110,1111} 

B、{11,10,001,101,0001}

C、 {00,010,0110,1000} 

D、{b,c,aa,ac,aba.abb,abc}

 本人：

B

>   参考答案：
>
>   B、构造出Huffman树后，左向分支标志为“0”，右向分支标志为”1”，则从根结点到叶结点之间的路径上分支字符组成的编码即为Huffrrtan编码，该编码必为前缀编码。任何一个字符的编码都不是另一个字符的编码的前缀。例如0.10.110.111即为前缀编码。10可以成为101的前缀，所以B不是前缀编码。
>
>   ==若没有一个编码是另一个编码的前缀，则这样的编码被称为前缀编码==

#### T6（二叉树的前序遍历（非递归））

请写出利用栈对二叉树进行先序遍历的非递归算法



#### T7

链表删除





### 操作系统

#### T1（基本分页存储）

对一个将页表存放在内存中分页系统：

（1）如果访问内存需要0.2微秒，有效访问时间是多少？

（2）如果加一快表，且假定在快表中找到页表项的机率为90%则有效访问时间又多少，假定查找快表需花的时间为0



本人：

（1）操作系统先访问页表，得到其物理地址，然后在访问其物理地址，需访问内存两次，所以需要时间：2*0.2=0.4(us)

（2）采用快表(0+0.2)=0.2(us)，有效访问时间0.2\*0.9+0.4\*0.1=0.22(us)

>   参考答案：
>
>   分页系统要访问两次，第一次要访问页表，将页号换成页地址，并与偏移量相加，得出实际地址，第二次要访问实际的地址的，所以所用时间是0.4μs，如果有快表，命中率为90%，则访问时间为0.2\*90%+0.4\*10%=0.18+0.04=0.22μs



#### T2（进程与线程）

试从调度性、并发性、拥有资源及系统开销方面，对进程和线程进行比较

本人：

调度性：在传统操作系统中进程是系统调度和资源分派的基本单位，在引入线程操作系统中线程是系统调度的基本单位，进程仍然是系统资源分派的基本单位

并发性：引入进程后，不仅可以进程之间并发运行，而且可以线程之间并发运行，提高了系统的并发性

拥有资源：只有进程拥有独立的资源，但是线程可以共享进程的资源

系统开销：在引入线程操作系统中同一进程的线程之间调度不需要引起进程的切换，所以开销更小



>   参考答案：
>
>   (1)调度性。线程在OS 中作为调度和分派的基本单位,进程只作为资源拥有的基本单位。
>
>   (2)并发性。进程可以并发执行,一个进程的多个线程也可并发执行。
>
>   (3)拥有资源。进程始终是拥有资源的基本单位,线程只拥有运行时必不可少的资源,本
>
>   身基本不拥有系统资源,但可以访问隶属进程的资源。
>
>   (4)系统开销。操作系统在创建、撤消和切换进程时付出的开销显著大于线程。



#### T3（进程调度与作业调度）（❌）

两道批作业处理的系统，sjf作业调度和优先级进程调度

计算平均周转时间

网上找题目：

有一个具有两道作业的批处理系统，作业调度采用短作业优先的调度算法，进程调度采用以优先数为基础的抢占式调度算法，有如下表所示的作业序列(表中所列作业优先数即为进程优先数，数值越小优先级越高)。 

(1)列出所有作业进入内存时刻及结束时刻。 

(2)计算平均周转时间。 

| 作业名 | 到达时刻(时) | 估计运行时间(分钟) | 优先数 |
| ------ | ------------ | ------------------ | ------ |
| A      | 10：00       | 40                 | 5      |
| B      | 10：20       | 30                 | 3      |
| C      | 10：30       | 50                 | 4      |
| D      | 10：50       | 20                 | 6      |

本人：

段作业优先： 

| 作业名 | 到达时刻(时) | 估计运行时间(分钟) | 优先数 | 进入内存时刻 | 结束时刻 | 周转时间（分钟） | 等待时间（分钟） |
| :----: | :----------: | :----------------: | :----: | :----------: | :------: | :--------------: | :--------------: |
|   A    |    10：00    |         40         |   5    |    10：00    |  10：40  |        40        |        0         |
|   B    |    10：20    |         30         |   3    |    10：40    |  11：10  |        50        |        20        |
|   C    |    10：30    |         50         |   4    |    11：30    |  12：20  |       110        |        60        |
|   D    |    10：50    |         20         |   6    |    11：10    |  11：30  |        40        |        20        |

平均周转时间：（40+50+110+40)/4=60(min)

优先级调度算法

| 作业名 | 到达时刻(时) | 估计运行时间(分钟) | 优先数 | 进入内存时刻 | 结束          时刻 | 周转时间（分钟） | 等待时间（分钟） |
| :----: | :----------: | :----------------: | :----: | :----------: | :----------------: | :--------------: | :--------------: |
|   A    |    10：00    |         40         |   5    |    10：00    |       12：00       |       120        |        80        |
|   B    |    10：20    |         30         |   3    |    10：20    |       10：50       |        30        |        0         |
|   C    |    10：30    |         50         |   4    |    10：50    |       11：40       |        70        |        20        |
|   D    |    10：50    |         20         |   6    |    12：00    |       12：20       |        90        |        70        |

平均周转时间：(120+30+70+90)/4

>   参考答案：
>
>   每个作业运行将经过两个阶段：作业调度（SJF算法）和进程调度（优先数抢占式）。另外，批处理最多容纳2道作业，更多的作业将在后备队列等待。 
>
>   （1）10：00，作业A到达并投入运行。 
>
>   （2）10：20，作业B到达且优先权高于作业A，故作业B投入运行而作业A在就绪队列等待。 
>
>   （3）10：30，作业C到达，因内存中已有两道作业，故作业C进入作业后备队列等待。 
>
>   （4）10：50，作业B运行结束，作业D到达，按SJF短作业优先算法，作业D被装入内存进入就绪队列。而由于作业A的优先级高于作业D，故作业A投入运行。 
>
>   （5）11：10，作业A运行结束，作业C被调入内存，且作业C的优先级高于作业D，故作业C投入运行。 
>
>   （6）12：00，作业C运行结束，作业D投入运行。 
>
>   （7）12：20，作业D运行结束。 各作业周转时间为：作业A  70，作业B  30，作业C  90，作业D  90。平均作业周转时间为70分钟。
>
>   ![5b63b22b52f85793bda7747b2db45335.jpg](https://gowi-picgo.oss-cn-shenzhen.aliyuncs.com/202302192016493.png)
>
>   | 作业名 | 到达时刻Ts | 进内存时间Tb | 有效时间Te | 结束时间Tf | 周转时间Tr | 带权周转时间Tr/Te |
>   | ------ | ---------- | ------------ | ---------- | ---------- | ---------- | ----------------- |
>   | A      | 10:00      | 10:00        | 40         | 11:10      | 70         | 1.75              |
>   | B      | 10:20      | 10:20        | 30         | 10:50      | 30         | 1                 |
>   | C      | 10:30      | 11:00        | 50         | 12:00      | 90         | 1.8               |
>   | D      | 10:50      | 10:50        | 20         | 12:20      | 90         | 4.5               |
>
>   平均周转时间：(70+30+90+90)/4=70
>
>   平均带权周转时间：(1.75+1+1.8+4.5)/4=2.26



#### T4（死锁）

RAG死锁化简





### 计算机网络

#### T1（IP计算与子网划分）

子网号计算



## 2018

### 程序设计

#### T1（基本程序设计）

![image-20230219205039410](https://gowi-picgo.oss-cn-shenzhen.aliyuncs.com/202302192050606.png)

一共n个数字，设计一个算法，找到从金字塔顶端起到最后一行，最长的路径





#### T2（排序与文件操作）

把一个文件中的字符排序后放入到另外一个文件中

```cpp
#include <cstdio>
#include <cstdlib>

#define N 100

int main()
{
   int n = 0;
   char str[N], ch;
   FILE *f1 = fopen("../2018/data.txt", "r+");
   FILE *f2 = fopen("../2018/new_data.txt", "w");
   if (f1 == NULL || f2 == NULL)
   {
      printf("文件操作失败\n");
      exit(0);
   }
   while ((ch = fgetc(f1)) != EOF)
   {
      if (ch != ',')
      {
         str[n++] = ch;
      }
   }
   str[n] = '\0';
   for (int i = 1; i < n; ++i)
   {
      for (int j = 0; j < n - 1; ++j)
      {
         if (str[j] > str[j + 1])
         {
            char c = str[j];
            str[j] = str[j + 1];
            str[j + 1] = c;
         }
      }
   }
   for (int i = 0; i < n; ++i)
   {
      fprintf(f2, "%c,", str[i]);
   }
   return 0;
}
```



### 数据结构

#### T1（链表的基本操作）

链表删除



#### T2（二叉树的遍历）

二叉树左右子树互换





###  操作系统

#### T1（进程的同步与互斥）

pv操作（生产者消费者）

本人：

```c
Semaphore mutex=1
Semaphore empty=1
Semaphore full=0

Producer{
	while(1){
        produce()
		p(empty);
		p(mutex);
		write_to_buffer()
		v(mutex)
		v(full)
    }
};

Comsumer{
	while(1)
    {
        p(full);
		p(mutex);
		read_from_buffer();
		v(mutex);
		v(empty);
		comsume();
    }
};

```



#### T2（进程调度算法）

时间片轮转法

非强占试调度算法

先来先服务（一共四个进程，先后按顺序一次进入）

网上找题：

有5个任务A，B，C，D，E，它们几乎同时先后达到，预计它们运行的时间为10，6，2，4，8 min。其优先级分别为3，5，2，1，4, 这里5 为最高优先级。对下列每一种调度算法，计算其平均进程周转时间（进程切换开销可不考虑）。

1 ） 先来先服务算法。

2） 优先级调度算法。（非抢占式）

3） 时间片轮转调度算法。（时间片 2min）

4） 短进程优先调度算法

| 进程名 | 运行时间 | 优先级 |
| ------ | -------- | ------ |
| A      | 10       | 3      |
| B      | 6        | 5      |
| C      | 2        | 2      |
| D      | 4        | 1      |
| E      | 8        | 4      |

本人：

1）先来先服务算法

| 进程名 | 运行时间 | 优先级 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | ------ | -------- | -------- | -------- | -------- | ------------ |
| A      | 10       | 3      | 0        | 10       | 0        | 10       | 1            |
| B      | 6        | 5      | 10       | 16       | 10       | 16       | 8/3          |
| C      | 2        | 2      | 16       | 18       | 16       | 18       | 9            |
| D      | 4        | 1      | 18       | 22       | 18       | 22       | 5.5          |
| E      | 8        | 4      | 22       | 30       | 22       | 30       | 3.75         |

2） 优先级调度算法。（非抢占式）

| 进程名 | 运行时间 | 优先级 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | ------ | -------- | -------- | -------- | -------- | ------------ |
| A      | 10       | 3      | 14       | 24       | 14       | 24       | 2.4          |
| B      | 6        | 5      | 0        | 6        | 0        | 6        | 1            |
| C      | 2        | 2      | 24       | 26       | 24       | 26       | 13           |
| D      | 4        | 1      | 26       | 30       | 26       | 30       | 7.5          |
| E      | 8        | 4      | 6        | 14       | 6        | 14       | 1.75         |

3） 时间片轮转调度算法。（时间片 2min）

| 进程名 | 运行时间 | 优先级 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | ------ | -------- | -------- | -------- | -------- | ------------ |
| A      | 10       | 3      | 0        | 30       | 20       | 30       | 3            |
| B      | 6        | 5      | 2        | 24       | 18       | 24       | 4            |
| C      | 2        | 2      | 4        | 6        | 4        | 6        | 3            |
| D      | 4        | 1      | 6        | 16       | 12       | 16       | 4            |
| E      | 8        | 4      | 8        | 28       | 20       | 28       | 3.5          |

4） 短进程优先调度算法

| 进程名 | 运行时间 | 优先级 | 开始时间 | 结束时间 | 等待时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | ------ | -------- | -------- | -------- | -------- | ------------ |
| A      | 10       | 3      | 20       | 30       | 20       | 30       | 3            |
| B      | 6        | 5      | 6        | 12       | 6        | 12       | 2            |
| C      | 2        | 2      | 0        | 2        | 0        | 2        | 1            |
| D      | 4        | 1      | 2        | 6        | 2        | 6        | 1.5          |
| E      | 8        | 4      | 12       | 20       | 12       | 20       | 2.5          |



### 计算机网络

#### T1（应用层与网络协议）

用户输入www.Baidu.com，得到界面的过程中，运用到物理层，传输层等那些协议，并写出协议的作用，写出传输过程

本人：

网络层：

IP：

传输层：

TCP：建立面向连接的可靠的传输服务，来保障内容的正确性

UDP：连接无连接的尽最大努力的传输服务

应用层：

DNS：基于UDP，通过DNS可以找到域名所对应的IP地址

HTTP：基于TCP，传输请求内容

过程：

1.  用户通过浏览器请求域名
2.  DNS服务器解析相关域名，并获得其对应的IP地址
3.  用户与服务器建立TCP连接
4.  服务器向用户传输数据
5.  传输完成断开TCP连接
6.  浏览器渲染相关数据



>   参考答案：
>
>   按照时间顺序：
>
>   1.  客户端浏览器获取用户在地址栏输入的域名。
>   2.  客户端浏览器将域名发送给DNS域名系统，请求解析。
>   3.  DNS解析域名得到相应的IP，返回给客户端浏览器。
>   4.  客户端浏览器根据IP向服务器发起TCP三次握手，建立TCP连接。
>   5.  ==客户端浏览器向服务器发送HTTP请求，请求百度首页。==
>   6.  ==服务器通过HTTP响应向客户端浏览器返回百度首页文件。==
>   7.  释放TCP连接。
>   8.  客户端浏览器解析HTML文件，根据文件内容获取CSS、JS等资源文件，将页面渲染展示给用户。
>
>   TCP/IP五层模型中网络层及以上用到的协议：
>
>   -   应用层
>
>       HTTP：客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输
>       DNS：解析域名为目的IP
>
>   -   传输层
>
>       TCP：为HTTP提供可靠的数据传输
>       UDP：DNS使用UDP传输
>
>   -   网络层
>
>       IP：IP数据数据包传输和路由选择
>
>       ==ARP==：将本机的默认网关IP地址映射成物理MAC地址



#### T2（IP计算与子网划分）

算IP之类的

255.255.255.176（具体数字忘了）

广播地址

算最多多少地址

本人：

应该是无分类编址CIDR

网上找题

某单位申请了一-段IP地址: 200.23.16.0/23。 单位内由4个部门(A,B,C,D)组成，每个部门的主机数量分别是: 200(A), 100(B), 50(C), 40(D)。试将单位的总地址块200.23.16.0/23划分为4个子网分配各4个部门。
◆1.写出每个子网(地址块)
◆2. 每个子网的网络 前缀?子网掩码?
◆3.每个子网的广播地址?主机可用地址范围?



200.23.16.0/23=200.23.0100 000x.xxxx xxxx

| 部门 | 主机数目 | IP地址范围       | 网络号        | 广播地址      | 子网掩码        | 主机可用范围                |
| ---- | -------- | ---------------- | ------------- | ------------- | --------------- | --------------------------- |
| A    | 200      | 200.23.16.0/24   | 200.23.16.0   | 200.23.16.255 | 255.255.255.0   | 200.23.16.1-200.23.16.254   |
| B    | 100      | 200.23.17.0/25   | 200.23.17.0   | 200.23.17.127 | 255.255.255.128 | 200.23.17.1-200.23.17.126   |
| C    | 50       | 200.23.17.128/26 | 200.23.17.128 | 200.23.17.191 | 255.255.255.192 | 200.23.17.129-200.23.17.190 |
| D    | 40       | 200.23.17.192/26 | 200.23.17.192 | 200.23.17.255 | 255.255.255.192 | 200.23.17.193-200.23.17.254 |



## 2019

### 程序设计

#### T1（基本程序设计）

输入一个年月日，再输入一个数字X（x为任意整数），输出加上X后的年月日（考虑跨年跨月 ，闰年闰月问题）

```cpp
#include <cstdio>

int main()
{
	int year, month, day, x;
	scanf("%d,%d,%d,%d", &year, &month, &day, &x);
	day += x;
	while (1)
	{
		if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)
		{
			if (day > 31)
			{
				day -= 31;
				month++;
			}
			else
			{
				break;
			}
			if (month > 12)
			{
				year++;
				month = 1;
			}
		}
		if (month == 2)
		{
			if (year % 4 == 0 || year % 400 == 0)
			{
				if (day > 29)
				{
					day -= 29;
					month++;
				}
				else
				{
					break;
				}
			}
			else
			{
				if (day > 28)
				{
					day -= 28;
					month++;
				}
				else
				{
					break;
				}
			}
		}
		if (month == 4 || month == 6 || month == 9 || month == 11)
		{
			if (day > 30)
			{
				day -= 30;
				month++;
			}
			else
			{
				break;
			}
		}
	}
	printf("%d-%d-%d", year, month, day);
	return 0;
}
```



#### T2（括号匹配）

一个文件里面存的都是正反括号（就这种“（（）））”），读取文件，让求匹配的括号个数，两个（（和两个））为一次匹配 例如（（））（））匹配次数为两次。





### 操作系统

#### T1（进程调度算法）

调度算法算平均周转时间





#### T2（动态分区算法）

动态分区分配的四个算法

网上找题目

给定五个分别为a:100 KB，b:500 KB，c:200 KB，d:300 KB和e:600 KB的内存分区，分别用the first-fit, best-fit, and worst-fit处理以下进程请求 A: 212 KB，B: 417 KB，C: 112 KB和D: 426 KB。

本人

采用首次适应算法

A进程分配b分区，B进程分配e分区，C进程分配c分区，d进程无法分配

采用最佳适应算法

A进程分配d分区，B进程分配b分区，C进程分配c分区，D进程e分区

采用最坏适应算法

A进程分配e分区，B进程分配b分区，C进程分配d分区，d进程无法分配



>   参考答案
>
>   first-fit（首次适应算法）
>   该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。每次都是从头开始。
>   步骤如下：
>   212kb，此时进程选择500kb，剩下288kb
>   417kb，此时进程选择600kb
>   112kb，此时进程选择288kb
>   426kb，此进程无分配
>
>   the best-fit（最佳适应算法）
>   将所有的空闲分区按其从小到大排序，有新作业的时候，按从小查找，直到找一个可以满足此作业的分区大小。
>
>   100kb，200kb，300kb，500kb，600kb
>   步骤如下：
>   212kb，此时进程选择300kb
>   417kb，此时进程选择500kb
>   112kb，此时进程选择200kb
>   426kb，此时进程选择500kb
>
>   the worst-fit（最坏适应算法）
>   将所有的空闲分区按其从大到小排序，总是挑选一个最大的空闲分区分割给作业使用。
>   600kb，500kb，300kb，200kb，100kb
>   步骤如下：
>   212kb，此时进程选择600kb，剩下388kb
>   417kb，此时进程选择500kb
>   112kb，此时进程选择388kb
>   426kb，此进程无分配



### 计算机网络

#### T1（IP计算与子网划分）

给出一个IP和子网掩码，算网络号，最大主机数，网络地址范围，还有一个忘了

网上找题

已知某主机的IP地址为：192.178.110.200，子网掩码为：255.255.255.224，请推导出：（5分）
（1） 该主机所在的网络地址。
（2） 网络内允许的最大主机数。
（3） 网络内主机IP地址的范围。



本人：

子网掩码：255.255.255.244=255.255.255.1110 0000

主机IP：192.178.110.200=192.178.110.1100 1000

网络号：192.178.110.192

主机数目：2^5^-2=30

主机IP范围：192.178.110.193-192.178.110.222



>   参考答案：
>
>   11000000.10110010.01101110.11001000 (192.178.110.200的二进制IP地址)
>   11111111.11111111.11111111.11100000 (255.255.255.224的二进制子网掩码)
>   11000000.10110010.01101110.11000000 (网络地址，即192.178.110.192) 11111111.11111111.11111111.11100000 (255.255.255.224的二进制子网掩码)
>   网络位：27	
>   主机位：5
>   主机数 = 2^5-2=30(因为不包括**网络地址**和**广播地址**所以要减2)
>   网络地址：IP地址网络位不变，主机位变0，再化成十进制
>   11000000.10110010.01101110.11001000 (192.178.110.200的二进制IP地址)
>   前27位为网络位，不变。后5位为主机位，全变0。
>   11000000.10110010.01101110.11000000 (即192.178.110.192)
>   广播地址：IP地址网络位不变，主机位变1，再化成十进制
>   11000000.10110010.01101110.11001000 (192.178.110.200的二进制IP地址)
>   前27位为网络位，不变。后5位为主机位，全变1。
>   11000000.10110010.01101110.11011111 (即192.178.110.223)
>   所以网络内主机的IP地址范围为192.178.110.193~192.178.110.222



#### T2（socket编程）

利用socket进行编程TCP

```python
# 服务端
from socket import *

IP = '127.0.0.1'
PORT = 50000
BUFLEN = 512

listenSocket = socket(AF_INET, SOCK_STREAM)
listenSocket.bind((IP, PORT))

listenSocket.listen(5)
print(f"服务器启动成功，在{PORT}端口号等待客户端连接...")

# socket.accept()
# 接受一个连接。此 socket 必须绑定到一个地址上并且监听连接。返回值是一个 (conn, address) 对，其中 conn 是一个 新 的套接字对象，用于在此连接上收发数据，address 是连接另一端的套接字所绑定的地址。
dataSocket, addr = listenSocket.accept()
print("接受一个客户端连接：", addr)

while True:
    recved = dataSocket.recv(BUFLEN)

    if not recved:
        break

    info = recved.decode()
    print(f'收到对方的信息：{info}')

    dataSocket.send(f'服务端接收到了信息{info}'.encode())

dataSocket.close()
listenSocket.close()
```



```python
# 客户端
from socket import *

IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 512

dataSocket = socket(AF_INET, SOCK_STREAM)

dataSocket.connect((IP, SERVER_PORT))

while True:
    toSend = input(">>>")
    if toSend == 'exit':
        break

    dataSocket.send(toSend.encode())

    recved = dataSocket.recv(BUFLEN)

    if not recved:
        break

    print(recved.decode())

dataSocket.close()
```



## 2020

### 程序设计

### T1

编写一个函数实现十进制向二进制转换的功能,函数的输入为一个十进制数,输出为一个二进制数,如输入37,输出为100101



```c
#include<stdio.h>

void fun(int x)
{
   if (x)
   {
      fun(x / 2);
      printf("%d", x % 2);
   }
}

int main()
{
	int x;
	scanf("%d", &x);
	if (x == 0)
	{
		printf("0");
	}
	else
	{
		fun(x);
	}
    return 0;
}
```



#### T2

请编写一个排序算法,实现对数字x[n]的排序,要求时间复杂度不高于O(nlogn)。

```cpp
#define N 10

#include <cstdio>

int partition(int x[], int low, int high)
{
   int pivot = x[low];
   while (low < high)
   {
      while (low < high && pivot <= x[high])
      {
         high--;
      }
      x[low] = x[high];
      while (low < high && pivot >= x[low])
      {
         low++;
      }
      x[high] = x[low];
   }
   x[low] = pivot;
   return low;
}

void QuickSort(int x[],int low,int high)
{
   if (low<high)
   {
      int pivot_pos= partition(x,low,high);
      QuickSort(x,low,pivot_pos-1);
      QuickSort(x,pivot_pos+1,high);
   }
}

int main()
{
   int x[N]={22,5,-4,-139,5,124,46,234,64,2},low=0,high=N-1;
   QuickSort(x,low,high);
   for (int i = 0; i < N; ++i)
   {
      printf("%d,",x[i]);
   }
   return 0;
}
```



### 操作系统

#### T1 （进程调度算法）（❌）

有周期性实时任务A和B:任务A执行时间为10ms,每20ms执行一次;任务B执行时间为25ms,每50ms执行一次。0时刻，A1和B1同时到达。各任务的截止时间是下次同类任务到达之前。



![image-20230220201200505](https://gowi-picgo.oss-cn-shenzhen.aliyuncs.com/202302202012638.png)

(1)  按照周期性任务的一般原则,请给出A3和B2的截止时间。

(2)  请给出0时刻A1任务和B1任务的松弛度。

(3)  按照最低松弛度优先算法，画出各任务的执行过程图。



本人：

1）

A3截止时间：40+10=50ms

B2截止时间：50+25=75ms

2）

0时刻A1任务的松弛度：20-10-0=10

0时刻B1任务的松弛度：50-25-0=25

3）

0时刻A1任务的松弛度：20-10-0=10

0时刻B1任务的松弛度：50-25-0=25

所以A1运行时间0-10，运行10ms

10-20时刻A2进程没有到来运行B1 进程

易知A2的最慢30时刻必须开始，其次松弛度为0

B2运行时间10-30，运行20ms，剩余5ms

A2运行时间30-40，运行10ms

30时刻A3任务的松弛度：60-10-40=10

30时刻B1任务的松弛度：

B2运行时间10-30，40-45，运行25ms

35时刻

<font color=red>(算到心态崩了)</font>



>   参考答案：
>
>   松弛度=必须完成时间-本身运行时间-当前时间
>   t=0s时，A1=20-10-0=10✓
>   B1=50-25-0=25
>   t=10s时，A2未到，所以执行B1。犹豫A2最低容忍时间为
>   30，所以B1可以执行到30s
>   t=30s时，A2已到，B1未完成，所以对A2，B1进行比较
>   A2=40-10-30=0✓
>   B1=50-5-30=15 B1已经执行20s，运行时间为5s
>   t=40s时，A3已到，B1未完成，所以对A3，B1进行比较
>   A3=60-10-40=10
>   B1=50-5-40=5✓ B1执行5s
>   t=45s时，B2已到，对A3，B2进行比较
>   A3=60-10-45=5✓
>   B2=100-25-45=30
>   t=55s时，A4未到，执行B2。A4最低容忍度为70，B2执行
>   到70s，B2执行15s
>   t=70s时，A4已到，比较A4，B2
>   A4=80-10-70=0✓
>   B2=100-15-70=15
>   t=80s时，A5已到，比较A5，B2
>   A5=100-10-80=10
>   B2=100-10-80=10
>   这里A5和B2的松弛度相同，A5的最低容忍度为90，B2不确定，只要在80-100之间完成即可，所以在A5不需要执行的时间内可以执行B2，90s时执行A5



扩展：

**任务的松弛度=必须完成的时间-其本身的运行时间-当前时间**





#### T2（进程的同步与互斥）

假定一个进程中有三个线程P、Q和R,这三个线程都调用函数执行特定功能,之后更新一个全局（共享）变量count，如下图所示，请定义信号量并协调这三个进程按如下顺序执行:QS1早于PS1执行；PS1早于RS1执行；QS2晚于RS1执行；PS2和RS2晚于QS2执行。请定义合适的信号量或锁机制在P、Q和R中插入代码,实现上述执行顺序及对count的更新。

|                          P                          |                          Q                          |                       R                        |
| :-------------------------------------------------: | :-------------------------------------------------: | :--------------------------------------------: |
| PS1()<br />  PS2()<br />  count = count + 3  <br /> | QS1()<br />  QS2() <br /> count = count - 2  <br /> | RS1()<br />  RS2()<br />  y = count + 5 <br /> |

```c
Semaphore mutex1=1;
Semaphore mutex2=0;
Semaphore mutex3=0;
Semaphore mutex4=0;
Semaphore mutex5=0;
Semaphore mutex6=0;

P{
	while(1)
	{
		P(mutex2);
        PS1();
        V(mutex3);
        P(mutex5);
        PS2();
	}
}

Q{
    while(1)
    {
        P(mutex1);
        QS1();
        V(mutex2);
        P(mutex4);
        QS2();
        V(mutex5);
        V(mutex6);
    }
}

R{
    while(1)
    {
        P(mutex3);
        RS1();
        V(mutex4);
        P(mutex6);
        RS2();
    }
}
```



#### T3（页面调用算法）

给定一组页面调用顺序，分配3个空的内存页面，分别给出FIFO、LRU、OPT算法的页面装载情况和对应的缺页中断出现次数。

网上找题目：

 1，2，3，4，2，1，5，6，2，1，2，3，7，6，3，2，1，2，3，6
当内存块数量分别为3时，试问FIFO、LRU、OPT这三种置换算法的缺页次数各是多少?







### 计算机网络

#### T1（应用层）

描述用户在浏览器输入www.sict.ac.cn后到页面在浏览器中显示经历的过程。

本人：

1.  用户通过浏览器请求域名www.sict.ac.cn
2.  DNS服务器解析域名，并得到其IP地址
3.  浏览器建立TCP连接
4.  用户发送HTTP请求
5.  服务器返回HTTP请求报文
6.  断开TCP连接
7.  浏览器渲染



#### T2（IP计算与子网划分）（❌）

某公司在甲城市设总部，在乙城设分公司。总部有260台需要联网设备进行宽带上网，请回答以下问题：

（1） 1个C段固定IP如何实现总部260台设备都能上网。需要加什么设备，实现什么功能？

（2） 如果要实现总部260台与分公司20台设备都能互相访问，如果实现分公司和总部的网络规划，需要加什么设备，实现什么功能？

（3） 总部260台设备，加上预留的50台空间，如果将这些设备地址都规划到一个局域网（LAN）中，局域网的地址、子网掩码该如何规划？

（4） 一个局域网中设备过多会带来什么问题，如何解决？



>   参考答案
>
>   (1) 为了让总部的260台设备都能上网，可以使用网络交换机或路由器来实现局域网内的设备访问互联网。需要将C段固定IP地址与子网掩码配置在路由器或交换机上，并通过NAT技术实现局域网内的IP地址转换为公网IP地址，以实现互联网访问。
>
>   (2) 要实现总部260台设备与分公司20台设备互相访问，可以在总部和分公司之间建立VPN隧道来实现远程访问。需要在总部和分公司各自的路由器上进行VPN配置，确保两个局域网之间可以相互访问。
>
>   (3) 如果要将总部260台设备与预留的50台设备地址都规划到一个局域网中，可以将局域网的地址设置为192.168.0.0，子网掩码为255.255.252.0，这样可以容纳512个IP地址，足够支持总部设备的需求。
>
>   (4) 当局域网中设备数量过多时，可能会出现网络拥堵、带宽不足等问题。可以通过以下方法来解决：分段划分子网，采用路由器隔离不同子网之间的通信；增加网络带宽，升级设备或者增加链路数量；优化网络配置，减少广播流量和冗余数据。





## 2022

### 数据结构

#### T1（线性表的基本概念）

线性表的顺序存储结构是一种( )。

A.随机存取的存储结构

B.顺序存取的存储结构

C.索引存取的存储结构

D.散列存取的存储结构 

本人：

A

>   参考答案：
>
>   A、根据基地址加上元素的序号，可以很方便地访问到任一元素，即随机存取的概念

#### T2（栈与队列）

栈和队列具有相同的( )。

A.抽象数据类型

B.逻辑结构

C.存储结构

D.运算

本人：

C

>   参考答案：
>
>   B



#### T3（二叉树的基本概念）

具有10个叶子结点的二叉树中有( )个度为2的结点。 

A.8

B.9

C.10

D.11 

本人：

B

>   参考答案：
>
>   根据二叉树的性质n0=n2+1,可知度为2的结点个数为9

#### T4（栈与队列）

Q是一个队列，S是一个空栈，实现将队列中的元素逆置的算法。



#### 操作系统

#### T1（核心态与用户态）

下列选项中，必须在核心态下执行的指令是( )。

A.从内存中取数

B.将运算结果装入内存

C.算术运算

D.输入/输出.

本人：

D

>   参考答案：
>
>   D、输入/输出指令涉及中断操作，而中断处理是由系统内核负责的，工作在核心态。而A、B、C选项均可通过使用汇编语言编程来实现，因此它们可在用户态下执行。

#### T2（进程的五种状态）

一个进程的基本状态可以从其他两种基本状态转变过去，这个基本的状态一定是()

本人：

就绪态

>   参考答案：
>
>   就绪态
>
>   执行态只能由就绪态转换而来；进程在执行时发生某些事件而无法继续执行时才转入阻塞状态；当进程执行完毕则进入完成状态；处于阻塞状态的进程在其所期待的事件发生时，则有阻塞状态转入就绪状态，正在执行的进程时间片用完，或在优先权优先的抢占式调度方式的系统中，当有更高优先权的进程就绪时，则会抢占正在执行的进程的处理机，从而使其从执行状态转换为就绪状态。因此应

#### T3（进程的基本概念）（❌）

一个计算机系统中，进程的最大数目主要受到() 限制。

本人：

操作系统

>   参考答案：
>
>   内存大小
>
>   进程创建需要占用系统内存来存放PCB的数据结构，所以，一个系统能够创建的进程总数是有限的，进程的最大数目取决于系统内存的大小，由系统安装时已经确定(若后期内存增加了，系统能够创建的进程总数也应增加，但是一般需要重新启动)。

#### T4（进程死锁）

一次分配所有资源的方法可以预防死锁的发生，它破坏死锁4个必要条件中的()。

本人：请求并保持

>   参考答案：
>
>   请求并保持：一次分配所有资源的方法是当进程需要资源时，一次性提出所有的请求，若请求的所有资源均满足则分配，只要有一项不满足，那么不分配任何资源，该进程阻塞，直到所有的资源空闲后，满足了进程的所有需求时再分配。这种分配方式不会部分地占有资源，所以就打破了死锁的四个必要条件之一，实现了对死锁的预防。但是，这种分配方式需要凑齐所有资源，所以当一个进程所需的资源比较多时，资源的利用率会比较低，甚至会造成进程的“饥饿”。

#### T5（死锁）

某系统中共有11台磁带机，X个进程共享此磁带机设备，每个进程最多请求 使用3台，则系统必然不会死锁的最大X值是( )。

本人：

2*(x-1)+3=11=>x=5

>   参考答案：
>
>   5
>
>   考虑一下极端情况，每个进程已经分配了两台磁带机，那么其中任何一个进程只要再分配一台磁带机即可满足它的最大需求，该进程总能运行下去直到结束，然后将磁带机归还给系统再次分配给其他进程使用。所以，系统中只要满足2X+1=1l这个条件即可认为系统不会死锁，解得X=5，也就是说，系统中最多可以并发5个这样的进程是不会死锁的。

#### T6（段页式存储）

在段页式分配中，CPU每次从内存中取一次数据需要( )次访问内存。

本人：

3

>   参考答案：
>
>   在段页式分配中，取一次数据时先从内存查找段表，再查找相应的页表，最后拼成物理地址后访问内存，共需要3次内存访问。

#### T7（进程与程序）

父进程创建子进程和主程序调用子程序有何不同?

本人：

进程是动态的，而程序是静态的，操作系统会为进程分配资源

>    参考答案：
>
>   父进程创建子进程后，父进程与子进程同时执行(并发)。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。

#### T8（管程的基本概念）

何为管程?

本人：

管程完成了对互斥和同步操作的封装，使程序员在编码过程中，更容易完成进程之间的同步或互斥

>   参考答案：
>
>   一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据

#### T9（进程死锁）

死锁发生的条件?

本人：

1.  互斥条件
2.  请求并保持条件
3.  循环等待条件
4.  不可剥夺条件

>   参考答案：
>
>   **1）互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
>
>   **2）请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
>
>   **3）不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
>
>   **4）环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

#### T10（进程死锁）

处理死锁有哪三种策略?

本人：

1.  一次性分配资源
2.  强制剥夺资源
3.  撤销进程

>   参考答案：
>
>   （1）死锁的预防。系统按预定的策略为进程分配资源，这些分配策略能使死锁的四个必要条件之一不成立，从而使系统不产生死锁。
>
>   （2）死锁的避免。系统动态地测试资源分配情况，仅当能确保系统安全时才给进程分配资源。银行家算法，寻找一个安全序列。
>
>   （3）死锁的检测。对资源的申请和分配不加限制，只要有剩余的资源就应把资源分配给申请者，操作系统要定时判断系统是否出现了死锁，当有

#### T11（系统冗余）

系统冗余有哪四种类型?

本人：

压根不知道什么是系统冗余

>   参考答案：
>
>   通常设计的冗余方式包括：CPU冗余、网络冗余、电源冗余。在极端情况下，一些系统会考虑全系统冗余，即还包括I/O冗余

#### T12（进程死锁）

某银行计算机系统要实现一个电子转账系统，基本业务流程是:首先对转出方和转入方的账户进行加锁，然后进行转账业务，最后转出方和转入方对账户进行解锁。若不采取任何措施，系统会不会发生死锁?为什么?

本人：

会，当转出方准备转出时，系统给转出方加锁，此时转出方的金额无法修改，与此同时，转入方给向转出方用户转账时，转让方加锁，金额无法修改，此时转入方请求转出方，转出方请求转让方，转出方请求转出方，构成死锁

>   参考答案:
>
>   会死锁。因为对两个账户进行加锁操作是可以分割执行的，若此时有两个用户同时进行转账，P1先对账户A进行加锁，再申请账户B；P2先对账户B进行加锁，再申请账户A，此时死锁。解决的办法是：可以采用资源顺序分配法，将A、B账户进行编号，用户转账时，只能按照编号由小到大进行加锁。也可以采用资源预分配法，要求用户在使用资源之前将所有资源一次性申请到。

### 计算机网络

#### T1（物理层的功能）

下列选项中，不属于OSI体系机构中物理层功能的是( )。

A.比特0和1使用何种电子信号表示

B.1个比特持续多长时间

C.传输能否在两个方向，上同时进行

D.避免快速发送方“淹没”慢速接受方

本人：

D

>   参考答案：
>
>   D

#### T2（协议与服务）

协议与服务有何区别?

本人：

协议是面向对等实体之间的，同一层级之间的，而服务是面向相邻的上下两层之间的

>   参考答案：
>
>   协议是“水平的”，即协议是控制对等实体之间通信的规则。而服务是“垂直的”，即服务是由下层向上层通过层间接口提供的
>
>   协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。
>
>   协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。上层使用所提供的服务必须与下层交换一些命令，这些命令在OSI中称为服务原语。

#### T3（数据链路与物理链路）

数据链路(即逻辑链路)与链路(即物理链路)有何区别

本人：

数据链路是虚拟的链路，而物理链路是实际上建立起来通过物理线缆连接的链路

>   参考答案：
>
>   物理链路:就是一条无源的点到点的物理线路段,中间没有任何其他的交换结点。在进行数据通信时,两个计算机之间的通路往往是由许多的链路串接而成的。 逻辑链路:在物理线路之外,加上一些必要的规程来控制这些数据的传输。实现这些规程的硬件和软件加到链路上,就构成了逻辑链路。

#### T4（通信延迟）

分布式系统中的通信延迟依赖于哪几个因素?

#### T5

采用任意代码（框架）实现一个简单的分布式应用，要求客户端向服务器发送一个字符串，服务器收到此字符串之后向客户端回复“hello”



>   参考答案：
>
>   以下是一个使用Python语言和socket模块实现的简单分布式应用，其中包含一个服务器端和一个客户端。
>
>   服务器端代码：
>
>   ```python
>   import socket
>   
>   # 创建TCP/IP socket
>   sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
>   
>   # 绑定socket到一个地址和端口
>   server_address = ('localhost', 10000)
>   sock.bind(server_address)
>   
>   # 监听连接
>   sock.listen(1)
>   
>   while True:
>       # 等待连接
>       print('等待连接...')
>       connection, client_address = sock.accept()
>       try:
>           print('客户端连接:', client_address)
>           
>           # 接收数据
>           data = connection.recv(1024)
>           print('接收到数据:', data.decode('utf-8'))
>           
>           # 发送响应数据
>           response = 'hello'
>           connection.sendall(response.encode('utf-8'))
>       finally:
>           # 清理连接
>           connection.close()
>   
>   ```
>
>   客户端代码：
>
>   ```python
>   import socket
>   
>   # 创建TCP/IP socket
>   sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
>   
>   # 连接到服务器
>   server_address = ('localhost', 10000)
>   print('连接到服务器:', server_address)
>   sock.connect(server_address)
>   
>   try:
>       # 发送数据
>       message = 'Hello, server!'
>       print('发送数据:', message)
>       sock.sendall(message.encode('utf-8'))
>   
>       # 接收响应数据
>       data = sock.recv(1024)
>       print('接收到数据:', data.decode('utf-8'))
>   finally:
>       # 关闭连接
>       sock.close()
>   
>   ```
>
>   以上代码中，服务器端使用socket模块创建一个TCP/IP socket，绑定到一个地址和端口，并监听连接。当有客户端连接时，服务器端接收客户端发送的数据，并发送响应数据。
>
>   客户端使用socket模块创建一个TCP/IP socket，连接到服务器端，并发送数据。客户端接收服务器端的响应数据后，关闭连接。



### 数据库

#### T1

1个项目中的1名工程师只会有1名经理; 1个项目中的1名经理会带领多名工程师做该项目; 1名经理和他手下的1名工程师可能参与多个项目。创建关系型数据库表格，体现出三者之间的关系。

